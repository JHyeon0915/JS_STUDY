1. id와 class의 차이(in html) 언제사용, 어떻게 사용, css관점, js관점(어떻게 접근하는지
ID : 하나의 태그가 개별적인 스타일을 가질 수 있다.
     '#id명'으로 css를 적용할 수 있다.
     id는 하나만 가질 수 있다.
CLASS : 여러 태그가 종합적인 스타일을 가질 수 있다.
        '.class명'으로 css를 적용할 수 있다.
        class는 여러개씩 가질 수 있다.

2. async, await : Promise의 완성
async는 function앞에, await은 promise앞에 붙이는 키워드다.

3. arrow function, 화살표 함수 (람다)
함수와는 달리 this, arguments, super, next.target을 반환하지 않는다.
this를 바인딩하지 않으며 메소드 함수가 아닌 곳에 가장 적당하다.
일반적으로 함수를 호출하면 this는 전역 객체에 바인딩된다.
그러나 화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다. (Lexical this)
화살표 함수는 call, apply, bind메소드를 사용하여 this를 변경할 수 없다.
표현 : () => {}

4. eventLoop찾아보기 : 이거 면접에서 중요(영어자료 많이 찾아보기)
EventLoop는 Call Stack과 Callback Queue의 상태를 체크하여 Call Stack이 빈 상태가 되면
Callback Queue의 첫번째 콜백을 Call Stack으로 밀어넣는다.

5. solid 원칙 : 객체지향 5가지원칙 *중요*
솔리드 원칙이란 
    1). SRP(Single Resposiblility Principle), 단일 책임 원칙
        단 하나의 책임안을 가져야 하며 최소 단위는 객체이다.
        책임이란 객체가 할 수 있는 것과 해야하는 것으로 나뉘어져 있다.
        하나의 클래스가 다양한 책임을 갖는 경우가 문제되는 이유는 '변경'이라는 관점에서 문제가 되기 때문이다.
        잘 설계된 프로그램은 새로운 요구사항이나 변경이 있을 때 영향받는 부분을 최소화해야 한다.
        SRP가 지켜지지 않으면 응집도는 낮아지고 결합도는 올라가는 프로그램이 된다.
        AOP도 SRP의 예제가 될 수 있다.
            *AOP : 관점 지향 프로그래밍. 어떠한 로직을 기준으로 핵심 관점과 부가적인 관점으로 나누어 그 기준으로 모듈화 하는 것을 의미한다.
    2). OCP(Open-Close Principle), 개방-폐쇄 원칙
        기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계되어야 한다는 원칙이다.
        요구사항이 변경되었을 때 코드에서 변경되어야 하는 부분과 그렇지 않은 부분을 명확하게 구분해
        변경되어야 하는 부분을 유연하게 작성해야 한다.
        또한 확장에는 유연하게 반응하고, 변경은 최소화해야 한다.
        Production Code란 기존 코드의 전체 방식을 명확히 이해하고 있어야만 추가적인 작업이 가능한 코드다.
        또 다른 관점에서의 OCP : 클래스를 변경하지 않고도 대상 클래스의 변경을 변경할 수 있는 설계가 되어야 한다.
        이를 위해 Mock, Stub등의 객체들이 사용되고 단위테스트에서 유용하다.
            *단위테스트 : 모듈이나 애플리케이션 안에 있는 개별적인 코드 단위가 예상대로 작동하는지 확인하는 반복적 행위
                          코드를 테스트하는 형태를 취한다.
                          제대로 동작하는지 확인하는 것 외에 코드를 어떻게 작성하는지에 대해 생각할 수 있게 해줌.
    3). LSP(Liskov Substitution Princple)리스코프 치환 원칙
        자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위를 수행할 수 있어야한다는 의미이다.
        부모 클래스의 인스턴스 대신에 자식 클래스의 인스턴스로 대체해도 프로그램의 의미는 변화되지 않아야 한다.
        이를 위해 부모 클래스와 자식 클래스의 행위는 일관되어야 한다.
        부모가 수행하고 있는 책임을 그대로 수행하면서 추가적인 필드나 기능을 제공하려는 경우에만 상속을 하는 것이 바람직하다.
    4). DIP(Dependence Inversion Principle), 의존 역전 원칙
        객체끼리 의존 관계를 맺을 때 변화하기 어렵고 거의 변화가 없는 것에 의존하라는 원칙이다.
        변화하기 쉬운것과 변화하지 않는 것은 무엇을 기준으로 구분하는가?
        정책이나 전략과 같은 큰 흐름이나 개념 같은 추상적인 것은 변하기 어려운 것으로, 구체적인 방식, 사물 등과 같은 것은 변하기 쉬운 것으로 구분하면 좋다.
        abstract나 interface를 통해 관리함으로써 변경에 대해 유연하게 대처할 수 있다.
    5). ISP(Interface Segregation Principle), 인터페이스 분리 원칙
        클라이언트에서는 클라이언트 자신이 이용하지 않는 기능에는 영향을 받지 않아야 한다는 원칙이다.
        ISP를 지키려면 범용의 인터페이스를 만드는 것이 아닌 클라이언트에 특화된 인터페이스를 사용해야 한다.
        ISP와 SRP는 동일한 문제에 다른 해결책을 제시하고 있는 것과 비슷하다.
        하나의 클래스가 기능이 너무 많음 -> SRP는 책임을 분할, ISP는 인터페이스로 분할. 둘 다 충족할 수도있고 아닐 수도 있다.(책임을 적절히 분할하고 각각의 인터페이스 사용...)

6. MVC 모델
Model, View, Controller의 약자이다.
각각의 역할을 나누어서 코딩하는 모델(패턴)이다.
    Model : 시스템의 비즈니스 로직을 담당. 실제로 데이터 처리
    View : 화면의 표시, 입력 등의 처리를 담당. Model의 상태 표시
    Controller : 유저의 입력에 근거하여 Model과 View를 제어. Model과 View에 처리 요청

MVC모델의 장점
    분리되어 있기 때문에 분업해서 작업을 진행하기 편리하다.
    변경 및 수정이 있을 경우, 다른 영역에 영향이 미치지 않는다.
    
7. IoC : Inversion of Control 제어의 역전

--------------------------------------------------------------------------------------------------------
1. Test double
실제 객체를 대신해 테스팅에서 사용하는 모든 방법들
Dummy : 객체는 전달되지만 사용되지 않는 객체
Fake : 구현을 가지고는 있지만 실제 프로덕션에 적합하지 않는 객체
Spy : Stub의 역할을 가지면서 호출된 내용에 대해 약간의 정보를 기록한다.
Mock : 호출에 대한 기대를 명세하고 해당 내용에 따라 동작하도록 프로그래밍 된 객체이다.
Stub : 테스트에서 호출된 요청에 대해 미리 준비해둔 결과를 제공한다.
       테스트를 위해 프로그래밍된 내용 외에는 응답하지 않는다.

Mock을 사용하면 구현부와 결합되는 부분이 많아지는데 이 경우 리팩토링 시 방해요소가 된다.

2. npm

3. JS 엔진
JS엔진은 메모리 힙과 콜스택으로 구성되어있다.
자바스크립트는 단일 스레드 프로그래밍 언어이다. 즉 call stack이 하나이다.
    메모리 힙 : 메모리 할당이 일어나는 곳
    call stack : 코드가 실행될 떄 쌓이는 곳
자바스크립트는 단일 스레드 프로그래밍 언어이지만 Web API, Callback Queue, Event Loop로 인해
멀티 스레드처럼 보여진다.
